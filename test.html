<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>WebAR Saturn Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px; z-index: 2; opacity: 0.5; border: 1px solid #444; transform: scaleX(-1); border-radius: 8px;}
        #ui-layer { position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 10; pointer-events: none; }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; z-index: 20; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; display: block;}
        h1 { font-size: 18px; margin: 0; text-shadow: 0 0 10px #00ffcc; }
        p { font-size: 12px; opacity: 0.8; line-height: 1.5; }
        .key-point { color: #ffaa00; font-weight: bold; }
    </style>
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading" class="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ ¸å¿ƒ...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
<div id="ui-layer">
    <h1>ğŸª åœŸæ˜Ÿç²’å­åœº (Saturn Particle Field)</h1>
    <p>çŠ¶æ€: <span id="status">ç­‰å¾…æ‰‹åŠ¿...</span></p>
    <p>äº¤äº’æŒ‡å—ï¼š<br>
    1. <span class="key-point">å¼ å¼€/æ¡æ‹³</span>: ç¼©æ”¾æ˜Ÿçƒ<br>
    2. <span class="key-point">æåˆ(æ‹‡æŒ‡+é£ŸæŒ‡)</span>: æ§åˆ¶æ—‹è½¬<br>
    3. <span class="key-point">å¿«é€ŸæŒ¥æ‰‹</span>: äº§ç”Ÿç‰©ç†é£æš´<br>
    4. <span class="key-point">æ‰‹æŒå‰åç§»åŠ¨</span>: æ·±åº¦æ§åˆ¶</p>
    <p>FPS: <span id="fps">0</span> | ç²’å­æ•°: 16,000</p>
</div>

<video id="video-feed" autoplay playsinline muted></video>
<div id="canvas-container"></div>

<script>
    // --- é…ç½®å‚æ•° ---
    const CONFIG = {
        particleCount: 16000,
        colors: [0x8B4513, 0xD2B48C, 0xF4A460, 0xDEB887, 0xCD853F], // åœŸæ˜Ÿæ£•è‰²ç³»
        springStrength: 0.03, // å½’ä½å¼¹åŠ› (ç¡¬åº¦)
        friction: 0.92,       // ç©ºæ°”é˜»åŠ› (ä¸æ»‘æ„Ÿ)
        stormPower: 3.5,      // æŒ¥æ‰‹é£åŠ›å€ç‡
        baseRadius: 100,      // æ˜ŸçƒåŸºç¡€åŠå¾„
        ringInner: 140,
        ringOuter: 220
    };

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, particlesMesh;
    let originalPositions, currentPositions, velocities; // ç‰©ç†æ•°æ® Buffer
    let handLandmarks = null;
    let clock = new THREE.Clock();
    
    // äº¤äº’çŠ¶æ€
    let interactionState = {
        pinchDistance: 0,
        isPinching: false,
        handCentroid: new THREE.Vector3(),
        prevHandCentroid: new THREE.Vector3(),
        handVelocity: new THREE.Vector3(),
        handOpenness: 1.0, // 1.0 = normal, >1 open, <1 closed
        handDepth: 1.0,
        rotationSpeed: 0.002
    };

    // --- åˆå§‹åŒ– Three.js ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        // å¢åŠ ä¸€ç‚¹é›¾æ•ˆå¢å¼ºæ·±åº¦æ„Ÿ
        scene.fog = new THREE.FogExp2(0x050505, 0.0008);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.z = 600;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        createSaturnParticles();
        window.addEventListener('resize', onWindowResize, false);
    }

    // --- åˆ›å»ºç²’å­ç³»ç»Ÿ (åœŸæ˜Ÿç»“æ„) ---
    function createSaturnParticles() {
        const geometry = new THREE.BufferGeometry();
        originalPositions = new Float32Array(CONFIG.particleCount * 3);
        currentPositions = new Float32Array(CONFIG.particleCount * 3);
        velocities = new Float32Array(CONFIG.particleCount * 3); // é€Ÿåº¦ç‰©ç†é‡
        const colors = new Float32Array(CONFIG.particleCount * 3);

        const colorPalette = CONFIG.colors.map(c => new THREE.Color(c));

        for (let i = 0; i < CONFIG.particleCount; i++) {
            let x, y, z;
            let isRing = Math.random() > 0.4; // 60% ç²’å­åœ¨ç¯ä¸Šï¼Œ40% åœ¨çƒä½“

            if (!isRing) {
                // çƒä½“åˆ†å¸ƒ (Planet Body)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = CONFIG.baseRadius * Math.cbrt(Math.random()); // å‡åŒ€åˆ†å¸ƒ
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else {
                // ç¯çŠ¶åˆ†å¸ƒ (Ring)
                const theta = Math.random() * Math.PI * 2;
                const r = CONFIG.ringInner + Math.random() * (CONFIG.ringOuter - CONFIG.ringInner);
                x = r * Math.cos(theta);
                z = r * Math.sin(theta); // ç¯å¹³é“ºåœ¨ XZ å¹³é¢
                y = (Math.random() - 0.5) * 5; // æè–„çš„åšåº¦
                
                // ç»™ç¯å¢åŠ ä¸€ç‚¹å€¾è§’
                const tempY = y * Math.cos(0.4) - z * Math.sin(0.4);
                const tempZ = y * Math.sin(0.4) + z * Math.cos(0.4);
                y = tempY; z = tempZ;
            }

            // å¡«å…… Buffer
            originalPositions[i * 3] = x;
            originalPositions[i * 3 + 1] = y;
            originalPositions[i * 3 + 2] = z;

            currentPositions[i * 3] = x;
            currentPositions[i * 3 + 1] = y;
            currentPositions[i * 3 + 2] = z;

            // é¢œè‰²åˆ†é…
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 2.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particlesMesh = new THREE.Points(geometry, material);
        scene.add(particlesMesh);
    }

    // --- MediaPipe å¤„ç†é€»è¾‘ ---
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            handLandmarks = landmarks;

            // 1. è®¡ç®—æ‰‹æŒè´¨å¿ƒ (è¿‘ä¼¼)
            const wrist = landmarks[0];
            const middleFinger = landmarks[9];
            
            // æ˜ å°„ MediaPipe (0-1) åˆ° Three.js ä¸–ç•Œåæ ‡ (è¿‘ä¼¼æŠ•å½±)
            // å‡è®¾ Z=0 å¹³é¢ï¼Œè§†å£å®½åº¦æ˜ å°„
            const vector = new THREE.Vector3(
                (1 - middleFinger.x) * 2 - 1,
                -(middleFinger.y) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; // æŠ•å°„åˆ° Z=0
            const worldPos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            interactionState.prevHandCentroid.copy(interactionState.handCentroid);
            interactionState.handCentroid.copy(worldPos);

            // 2. è®¡ç®—æ‰‹é€Ÿ (é£æš´è§¦å‘)
            const velocity = new THREE.Vector3().subVectors(interactionState.handCentroid, interactionState.prevHandCentroid);
            interactionState.handVelocity.lerp(velocity, 0.5); // ç®€å•å¹³æ»‘

            // 3. æåˆæ£€æµ‹ (é£ŸæŒ‡8 - æ‹‡æŒ‡4)
            const p4 = landmarks[4];
            const p8 = landmarks[8];
            const pinchDist = Math.hypot(p8.x - p4.x, p8.y - p4.y);
            interactionState.isPinching = pinchDist < 0.05;

            // 4. æ‰‹æŒå¼ å¼€ç¨‹åº¦ (è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»)
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            tips.forEach(idx => {
                avgDist += Math.hypot(landmarks[idx].x - landmarks[0].x, landmarks[idx].y - landmarks[0].y);
            });
            avgDist /= 4;
            // å½’ä¸€åŒ–: 0.2 (é—­åˆ) ~ 0.5 (å¼ å¼€) -> æ˜ å°„åˆ° 0.5 ~ 2.0
            interactionState.handOpenness = THREE.MathUtils.mapLinear(avgDist, 0.1, 0.5, 0.5, 2.5);

            // 5. æ·±åº¦æ£€æµ‹ (æ‰‹éƒ¨ Bounding Box é¢ç§¯)
            // ç®€å•ç”¨æ‰‹è…•å’Œä¸­æŒ‡çš„è·ç¦»ä½œä¸ºæ·±åº¦çš„åæ¯”ä»£ç†
            const depthProxy = Math.hypot(wrist.x - middleFinger.x, wrist.y - middleFinger.y);
            interactionState.handDepth = THREE.MathUtils.mapLinear(depthProxy, 0.1, 0.4, 0.8, 1.5);

            updateUI("æ‰‹åŠ¿è¿½è¸ªä¸­");
        } else {
            handLandmarks = null;
            // æ— æ‰‹æ—¶ï¼Œé€Ÿåº¦è¡°å‡
            interactionState.handVelocity.multiplyScalar(0.9);
            // ç¼“æ…¢æ¢å¤é»˜è®¤ç¼©æ”¾
            interactionState.handOpenness = THREE.MathUtils.lerp(interactionState.handOpenness, 1.0, 0.05);
            updateUI("ç­‰å¾…æ‰‹åŠ¿...");
        }
    }

    function updateUI(status) {
        document.getElementById('status').innerText = status;
        if(interactionState.isPinching) document.getElementById('status').innerText = "çŠ¶æ€: æ—‹è½¬é”å®š";
        if(interactionState.handVelocity.length() > 20) document.getElementById('status').innerText = "çŠ¶æ€: ğŸŒªï¸ ç²’å­é£æš´";
    }

    // --- æ ¸å¿ƒç‰©ç†å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);
        
        const positions = particlesMesh.geometry.attributes.position.array;
        
        // æ—‹è½¬é€»è¾‘
        if (interactionState.isPinching) {
            // æåˆæ—¶æ ¹æ®æ‰‹çš„ä½ç½®å·®å¼‚æ—‹è½¬
            particlesMesh.rotation.y += (interactionState.handCentroid.x * 0.0001);
            particlesMesh.rotation.x -= (interactionState.handCentroid.y * 0.0001);
        } else {
            particlesMesh.rotation.y += interactionState.rotationSpeed;
        }

        // æ·±åº¦ç¼©æ”¾ (æ•´ä½“ç¼©æ”¾)
        const targetScale = interactionState.handDepth;
        particlesMesh.scale.setScalar(THREE.MathUtils.lerp(particlesMesh.scale.x, targetScale, 0.05));

        // ç‰©ç†è¿­ä»£
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;

            // 1. è·å–å½“å‰çŠ¶æ€
            let px = positions[idx];
            let py = positions[idx + 1];
            let pz = positions[idx + 2];

            let vx = velocities[idx];
            let vy = velocities[idx + 1];
            let vz = velocities[idx + 2];

            // 2. è®¡ç®—ç›®æ ‡ä½ç½® (åŸºäºæ‰‹æŒå¼ å¼€ç¨‹åº¦å˜å½¢)
            // å¦‚æœæ‰‹å¼ å¼€ï¼Œç›®æ ‡ä½ç½®å‘å¤–æ‰©æ•£
            let ox = originalPositions[idx] * interactionState.handOpenness;
            let oy = originalPositions[idx + 1] * interactionState.handOpenness;
            let oz = originalPositions[idx + 2] * interactionState.handOpenness;

            // 3. è®¡ç®—å¼¹åŠ› (Hooke's Law): F = k * (target - current)
            let fx = (ox - px) * CONFIG.springStrength;
            let fy = (oy - py) * CONFIG.springStrength;
            let fz = (oz - pz) * CONFIG.springStrength;

            // 4. è®¡ç®—é£æš´å¹²æ‰°åŠ› (Interaction Force)
            if (handLandmarks) {
                // å°†ç²’å­è½¬åˆ°ä¸–ç•Œåæ ‡å¯¹æ¯”ï¼Œæˆ–è€…å°†æ‰‹è½¬åˆ°å±€éƒ¨åæ ‡
                // è¿™é‡Œç®€å•å¤„ç†ï¼šæ‰‹çš„ä½ç½®ç›¸å¯¹äºå±å¹•ä¸­å¿ƒï¼Œç²’å­ä¹Ÿæ˜¯
                // è®¡ç®—ç²’å­ä¸æ‰‹çš„è·ç¦»
                // æ³¨æ„ï¼šparticlesMesh æœ‰æ—‹è½¬ï¼Œéœ€ç®€å•é€†å˜æ¢æˆ–åªè®¡ç®—å±å¹•ç©ºé—´è·ç¦»
                
                // ç®€åŒ–ï¼šå‡è®¾æ‰‹åœ¨ Z=200 å¤„äº§ç”Ÿé£åœº
                let dx = px - interactionState.handCentroid.x;
                let dy = py - interactionState.handCentroid.y;
                let distSq = dx*dx + dy*dy;

                // å¦‚æœæ‰‹é€Ÿå¤Ÿå¿«ï¼Œä¸”ç²’å­åœ¨é™„è¿‘
                const speed = interactionState.handVelocity.length();
                if (speed > 5.0 && distSq < 40000) { // 200 unit radius
                    const force = (10000 / (distSq + 100)) * speed * CONFIG.stormPower;
                    // æ²¿ç€æ‰‹é€Ÿæ–¹å‘å¹ï¼Œå¹¶å¸¦ä¸€ç‚¹çˆ†ç‚¸æ‰©æ•£
                    fx += interactionState.handVelocity.x * force * 0.5 + (dx * force * 0.1);
                    fy += interactionState.handVelocity.y * force * 0.5 + (dy * force * 0.1);
                    fz += interactionState.handVelocity.z * force * 0.5;
                }
            }

            // 5. ç§¯åˆ† (Velocity += Acceleration, Position += Velocity)
            vx += fx;
            vy += fy;
            vz += fz;

            // 6. é˜»å°¼ (Friction)
            vx *= CONFIG.friction;
            vy *= CONFIG.friction;
            vz *= CONFIG.friction;

            // 7. æ›´æ–°ä½ç½®
            positions[idx] = px + vx;
            positions[idx + 1] = py + vy;
            positions[idx + 2] = pz + vz;

            // ä¿å­˜é€Ÿåº¦
            velocities[idx] = vx;
            velocities[idx + 1] = vy;
            velocities[idx + 2] = vz;
        }

        particlesMesh.geometry.attributes.position.needsUpdate = true;
        
        // æ›´æ–° FPS
        document.getElementById('fps').innerText = Math.round(1 / clock.getDelta());
        renderer.render(scene, camera);
    }

    // --- å¯åŠ¨æµç¨‹ ---
    initThree();
    
    const videoElement = document.getElementById('video-feed');
    const hands = new Hands({locateFile: (file) => {
        return `https://unpkg.com/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    
    hands.onResults(onResults);
    
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    
    cameraUtils.start().then(()=> {
        console.log("Camera started");
        animate();
    }).catch(err => {
        console.error("Camera error:", err);
        document.getElementById('loading').innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–HTTPSç¯å¢ƒ";
    });

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>