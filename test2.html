<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Christmas Tree - Three.js + MediaPipe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; z-index: 2; border: 2px solid #D4AF37; border-radius: 8px; overflow: hidden; opacity: 0.8; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 3; color: #D4AF37; pointer-events: none; }
        h1 { margin: 0; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); font-weight: 300; letter-spacing: 2px; }
        .status { margin-top: 10px; font-size: 14px; color: #fff; opacity: 0.8; }
        .instruction { font-size: 12px; color: #aaa; margin-top: 5px; }
        
        /* Upload Button */
        #upload-btn { pointer-events: auto; background: rgba(212, 175, 55, 0.2); border: 1px solid #D4AF37; color: #D4AF37; padding: 8px 16px; margin-top: 20px; cursor: pointer; transition: 0.3s; text-transform: uppercase; font-size: 12px; letter-spacing: 1px; }
        #upload-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }
        #file-input { display: none; }
        
        /* Loading */
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; z-index: 10; font-size: 20px; display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>Gilded Memories Tree</h1>
        <div class="status" id="status-text">åˆå§‹åŒ–ç³»ç»Ÿ...</div>
        <div class="instruction">âœ‹ å¼ å¼€äº”æŒ‡: æ•£å¼€ | âœŠ æ¡æ‹³: èšåˆ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡ | ğŸ‘‹ ç§»åŠ¨: æ—‹è½¬è§†è§’</div>
        <button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ ç…§ç‰‡ (ç”Ÿæˆç…§ç‰‡äº‘)</button>
        <input type="file" id="file-input" multiple accept="image/*">
    </div>

    <div id="loader">æ­£åœ¨æ„å»ºç²’å­ç³»ç»Ÿ...</div>
    <div id="canvas-container"></div>
    <div id="video-container">
        <video class="input_video"></video>
    </div>

<script>
/**
 * æ ¸å¿ƒé…ç½®
 */
const CONFIG = {
    particleCount: 1500, // è£…é¥°ç²’å­æ•°é‡
    treeHeight: 40,
    treeRadius: 15,
    colors: {
        matteGreen: 0x2E4A3D,
        metallicGold: 0xD4AF37,
        christmasRed: 0x8A1C1C,
        white: 0xFFFFFF
    }
};

/**
 * çŠ¶æ€ç®¡ç†
 */
const STATE = {
    mode: 'TREE', // 'TREE', 'SCATTERED', 'ZOOM'
    handDetected: false,
    handPosition: { x: 0, y: 0 },
    pinchDistance: 0,
    targetRotation: { x: 0, y: 0 },
    photos: [] // å­˜å‚¨ç…§ç‰‡Mesh
};

/**
 * THREE.JS åˆå§‹åŒ–
 */
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 60);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ReinhardToneMapping;
container.appendChild(renderer.domElement);

// ç¯å…‰ç³»ç»Ÿ
const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(CONFIG.colors.metallicGold, 1.5, 100);
pointLight.position.set(10, 20, 20);
scene.add(pointLight);

const spotLight = new THREE.SpotLight(0xff0000, 2);
spotLight.position.set(-20, 20, 10);
scene.add(spotLight);

// åæœŸå¤„ç† (Bloom - è¾‰å…‰)
const renderScene = new THREE.RenderPass(scene, camera);
const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.threshold = 0.2;
bloomPass.strength = 1.2; // å¢å¼ºè¾‰å…‰
bloomPass.radius = 0.5;

const composer = new THREE.EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

/**
 * å‡ ä½•ä½“ä¸ç²’å­ç³»ç»Ÿ (InstancedMesh)
 */
const geometrySphere = new THREE.IcosahedronGeometry(0.5, 1);
const geometryCube = new THREE.BoxGeometry(0.6, 0.6, 0.6);

// æè´¨ï¼šå“‘å…‰ç»¿ä¸é‡‘å±é‡‘
const matGold = new THREE.MeshStandardMaterial({ 
    color: CONFIG.colors.metallicGold, 
    metalness: 1.0, 
    roughness: 0.2,
    emissive: 0x332200
});
const matGreen = new THREE.MeshStandardMaterial({ 
    color: CONFIG.colors.matteGreen, 
    roughness: 0.9, 
    metalness: 0.1 
});
const matRed = new THREE.MeshStandardMaterial({ 
    color: CONFIG.colors.christmasRed, 
    roughness: 0.3,
    metalness: 0.4,
    emissive: 0x220000
});

// å®ä¾‹åŒ–ç½‘æ ¼
const meshGold = new THREE.InstancedMesh(geometrySphere, matGold, CONFIG.particleCount / 2);
const meshGreen = new THREE.InstancedMesh(geometrySphere, matGreen, CONFIG.particleCount / 3);
const meshRed = new THREE.InstancedMesh(geometryCube, matRed, CONFIG.particleCount / 6);

scene.add(meshGold);
scene.add(meshGreen);
scene.add(meshRed);

// å­˜å‚¨ç²’å­æ•°æ®çš„æ•°ç»„
const particlesData = []; // { mesh, index, treePos, scatterPos, currentPos }

function initParticles() {
    const meshes = [meshGold, meshGreen, meshRed];
    let totalIndex = 0;

    meshes.forEach((mesh) => {
        const dummy = new THREE.Object3D();
        for (let i = 0; i < mesh.count; i++) {
            // 1. è®¡ç®—æ ‘å½¢åæ ‡ (èºæ—‹åœ†é”¥)
            const t = i / mesh.count; 
            const angle = t * Math.PI * 20 + (totalIndex * 0.1); // èºæ—‹
            const height = (t * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
            const radius = (1 - t) * CONFIG.treeRadius; // åº•éƒ¨å®½é¡¶éƒ¨çª„
            
            const treeX = Math.cos(angle) * radius;
            const treeZ = Math.sin(angle) * radius;
            const treeY = height;

            // 2. è®¡ç®—æ•£è½åæ ‡ (éšæœºçƒä½“åˆ†å¸ƒ)
            const rScatter = 40;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const scatterX = rScatter * Math.sin(phi) * Math.cos(theta);
            const scatterY = rScatter * Math.sin(phi) * Math.sin(theta);
            const scatterZ = rScatter * Math.cos(phi);

            // åˆå§‹åŒ–ä½ç½®
            dummy.position.set(treeX, treeY, treeZ);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);

            particlesData.push({
                mesh: mesh,
                index: i,
                treePos: new THREE.Vector3(treeX, treeY, treeZ),
                scatterPos: new THREE.Vector3(scatterX, scatterY, scatterZ),
                currentPos: new THREE.Vector3(treeX, treeY, treeZ),
                velocity: new THREE.Vector3(0,0,0) // ç”¨äºæ¼‚æµ®åŠ¨ç”»
            });
            totalIndex++;
        }
        mesh.instanceMatrix.needsUpdate = true;
    });
}
initParticles();

/**
 * ç…§ç‰‡äº‘ç³»ç»Ÿ
 */
const photoGroup = new THREE.Group();
scene.add(photoGroup);
const textureLoader = new THREE.TextureLoader();

document.getElementById('file-input').addEventListener('change', handleImageUpload);

function handleImageUpload(e) {
    const files = e.target.files;
    if (!files.length) return;

    document.getElementById('loader').style.display = 'block';

    // æ¸…é™¤æ—§ç…§ç‰‡
    while(photoGroup.children.length > 0){ 
        photoGroup.remove(photoGroup.children[0]); 
    }
    STATE.photos = [];

    let loadedCount = 0;
    Array.from(files).forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.src = event.target.result;
            const texture = new THREE.Texture(img);
            img.onload = () => { texture.needsUpdate = true; };

            const aspect = 1.3; // å‡è®¾ç«–å›¾æˆ–æ¡†
            const geo = new THREE.PlaneGeometry(3, 3 * aspect);
            const mat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            // åŠ è¾¹æ¡†
            const mesh = new THREE.Mesh(geo, mat);
            const borderGeo = new THREE.PlaneGeometry(3.2, 3.2 * aspect);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xD4AF37 });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.05;
            mesh.add(border);

            // è®¡ç®—åœ¨æ ‘ä¸Šçš„ä½ç½® (æ’å…¥åˆ°èºæ—‹ä¸­)
            const t = index / files.length;
            const angle = t * Math.PI * 10;
            const height = (t * CONFIG.treeHeight * 0.8) - (CONFIG.treeHeight / 2) + 5;
            const radius = ((1 - (t*0.8)) * CONFIG.treeRadius) + 2; // æ¯”ç²’å­ç¨å¾®é å¤–ä¸€ç‚¹
            
            const treePos = new THREE.Vector3(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
            
            mesh.position.copy(treePos);
            mesh.lookAt(0, height, 0); // é¢å‘ä¸­å¿ƒï¼Œæˆ–è€…åè¿‡æ¥é¢å‘å¤–
            mesh.rotateY(Math.PI); // é¢å‘å¤–

            // å­˜å‚¨ç…§ç‰‡æ•°æ®
            mesh.userData = {
                treePos: treePos.clone(),
                treeRot: mesh.rotation.clone(),
                scatterPos: new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*20 + 20),
                scatterRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                isZoomed: false
            };

            photoGroup.add(mesh);
            STATE.photos.push(mesh);

            loadedCount++;
            if(loadedCount === files.length) {
                document.getElementById('loader').style.display = 'none';
                document.getElementById('status-text').innerText = `å·²åŠ è½½ ${loadedCount} å¼ ç…§ç‰‡`;
            }
        };
        reader.readAsDataURL(file);
    });
}

/**
 * MediaPipe Hands è®¾ç½®
 */
const videoElement = document.getElementsByClassName('input_video')[0];
const statusText = document.getElementById('status-text');

const hands = new Hands({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(onHandsResults);

const cameraUtils = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({image: videoElement});
  },
  width: 320,
  height: 240
});
cameraUtils.start();

/**
 * æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
 */
function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        STATE.handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        
        // 1. è®¡ç®—æ‰‹æŒä¸­å¿ƒ (ç”¨äºæ—‹è½¬æ§åˆ¶)
        // åæ ‡å½’ä¸€åŒ– 0-1, æ˜ å°„åˆ° -1 åˆ° 1
        const x = (landmarks[9].x - 0.5) * 2; 
        const y = (landmarks[9].y - 0.5) * 2;
        STATE.handPosition.x = x;
        STATE.handPosition.y = y;

        // 2. æ‰‹åŠ¿åˆ†ç±»
        // è®¡ç®—æ‰‹æŒ‡ä¼¸å±•çŠ¶æ€
        const isThumbOpen = landmarks[4].x < landmarks[3].x; // ç®€åŒ–åˆ¤æ–­ (å³æ‰‹)
        const isIndexOpen = landmarks[8].y < landmarks[6].y;
        const isMiddleOpen = landmarks[12].y < landmarks[10].y;
        const isRingOpen = landmarks[16].y < landmarks[14].y;
        const isPinkyOpen = landmarks[20].y < landmarks[18].y;

        const openFingers = [isIndexOpen, isMiddleOpen, isRingOpen, isPinkyOpen].filter(Boolean).length;

        // æåˆè®¡ç®— (é£ŸæŒ‡æŒ‡å°–ä¸æ‹‡æŒ‡æŒ‡å°–è·ç¦»)
        const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
        STATE.pinchDistance = pinchDist;

        // çŠ¶æ€æœºè½¬æ¢é€»è¾‘
        if (pinchDist < 0.05) {
            // æåˆ -> æŠ“å–/ç¼©æ”¾æ¨¡å¼ (ä»…åœ¨ç…§ç‰‡å­˜åœ¨æ—¶)
            if (STATE.photos.length > 0 && STATE.mode !== 'TREE') {
                 // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šç›´æ¥æ”¾å¤§æœ€è¿‘çš„ä¸€å¼ æˆ–ä¸­å¿ƒç…§ç‰‡ï¼Œå®é™…åº”ç»“åˆRaycaster
                 toggleZoomMode(true);
            }
        } else if (openFingers >= 4) {
            // äº”æŒ‡å¼ å¼€ -> æ•£å¼€æ€
            if (STATE.mode !== 'SCATTERED' && STATE.mode !== 'ZOOM') {
                switchMode('SCATTERED');
            } else if (STATE.mode === 'ZOOM') {
                toggleZoomMode(false); // é€€å‡ºæ”¾å¤§
            }
        } else if (openFingers === 0) {
            // æ¡æ‹³ -> åˆæ‹¢æ€
            if (STATE.mode !== 'TREE') {
                switchMode('TREE');
            }
        }

        // 3. æ›´æ–°UIçŠ¶æ€åé¦ˆ
        let statusStr = `æ¨¡å¼: ${STATE.mode}`;
        if (pinchDist < 0.05) statusStr += " | ğŸ¤ æŠ“å–";
        else if (openFingers >= 4) statusStr += " | âœ‹ å¼ å¼€";
        else if (openFingers === 0) statusStr += " | âœŠ æ¡æ‹³";
        statusText.innerText = statusStr;

    } else {
        STATE.handDetected = false;
        // æ‰‹æ¶ˆå¤±æ—¶ï¼Œå¦‚æœåœ¨SCATTEREDæ¨¡å¼ï¼Œæ…¢æ…¢è‡ªåŠ¨æ—‹è½¬
    }
}

function switchMode(newMode) {
    if (STATE.mode === newMode) return;
    STATE.mode = newMode;
    
    // ä½¿ç”¨ GSAP è§¦å‘æ•´ä½“åŠ¨ç”»
    const duration = 1.5;
    
    // ç²’å­åŠ¨ç”»ç”± update å¾ªç¯ä¸­çš„ lerp å¤„ç†ï¼Œè¿™é‡Œä¸»è¦å¤„ç†ä¸€æ¬¡æ€§çš„è§¦å‘
    if (newMode === 'TREE') {
        gsap.to(camera.position, { z: 60, duration: 1.5 });
    } else if (newMode === 'SCATTERED') {
        gsap.to(camera.position, { z: 40, duration: 1.5 });
    }
}

function toggleZoomMode(active) {
    if (active && STATE.mode !== 'ZOOM') {
        STATE.mode = 'ZOOM';
        // éšæœºé€‰ä¸€å¼ ç…§ç‰‡æ”¾å¤§æ¼”ç¤ºï¼Œæˆ–è€…é€‰ä¸­é—´çš„
        const targetPhoto = STATE.photos[Math.floor(Math.random() * STATE.photos.length)];
        
        // ä¿å­˜åŸå§‹ä½ç½®ä»¥ä¾¿å¤åŸ
        // è¿™é‡Œç®€å•å¤„ç†ï¼šè®©ä¸€å¼ é£åˆ°é•œå¤´å‰
        gsap.to(targetPhoto.position, { x: 0, y: 0, z: 30, duration: 1 });
        gsap.to(targetPhoto.rotation, { x: 0, y: 0, z: 0, duration: 1 });
        gsap.to(targetPhoto.scale, { x: 2, y: 2, z: 2, duration: 1 });
        
    } else if (!active && STATE.mode === 'ZOOM') {
        STATE.mode = 'SCATTERED';
        // æ‰€æœ‰ç…§ç‰‡å¤ä½åˆ°æ•£å¼€æ€
        STATE.photos.forEach(p => {
            gsap.to(p.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            // ä½ç½®åœ¨ update ä¸­ä¼šè‡ªåŠ¨ lerp å› scatterPos
        });
    }
}

/**
 * åŠ¨ç”»ä¸»å¾ªç¯
 */
const clock = new THREE.Clock();
const dummy = new THREE.Object3D();
const raycaster = new THREE.Raycaster();

function animate() {
    requestAnimationFrame(animate);
    
    const time = clock.getElapsedTime();
    const dt = clock.getDelta();

    // 1. ç›¸æœºä¸åœºæ™¯æ—‹è½¬é€»è¾‘
    if (STATE.mode === 'SCATTERED' && STATE.handDetected) {
        // æ ¹æ®æ‰‹ä½ç½®æ—‹è½¬åœºæ™¯ (åå‘ç§»åŠ¨äº§ç”Ÿè§†å·®)
        const targetRotX = STATE.handPosition.y * 0.5;
        const targetRotY = STATE.handPosition.x * 0.5;
        
        // å¹³æ»‘æ’å€¼
        scene.rotation.x += (targetRotX - scene.rotation.x) * 0.05;
        scene.rotation.y += (targetRotY - scene.rotation.y) * 0.05;
    } else if (STATE.mode === 'TREE') {
        // æ ‘æ¨¡å¼ä¸‹è‡ªåŠ¨ç¼“æ…¢è‡ªè½¬
        scene.rotation.y += 0.002;
        scene.rotation.x *= 0.95; // å›æ­£
    }

    // 2. ç²’å­ä½ç½®æ›´æ–°
    const lerpFactor = 0.05; // ç§»åŠ¨é€Ÿåº¦

    particlesData.forEach(data => {
        let target;
        if (STATE.mode === 'TREE') {
            target = data.treePos;
        } else {
            // æ•£å¼€æ¨¡å¼å¢åŠ ä¸€ç‚¹æ­£å¼¦æ³¢æ¼‚æµ®
            target = data.scatterPos.clone();
            target.y += Math.sin(time + data.index) * 0.5;
        }

        // æ’å€¼ç§»åŠ¨
        data.currentPos.lerp(target, lerpFactor);
        
        // æ›´æ–° InstancedMesh çŸ©é˜µ
        dummy.position.copy(data.currentPos);
        
        // æ ‘æ¨¡å¼ä¸‹ç²’å­æ•´é½æ’åˆ—ï¼Œæ•£å¼€æ¨¡å¼ä¸‹éšæœºæ—‹è½¬
        if (STATE.mode === 'TREE') {
            dummy.rotation.set(0, 0, 0);
        } else {
            dummy.rotation.set(time * 0.2, time * 0.1, 0);
        }
        
        dummy.updateMatrix();
        data.mesh.setMatrixAt(data.index, dummy.matrix);
    });

    // æ ‡è®°æ‰€æœ‰ InstanceMesh éœ€è¦æ›´æ–°
    meshGold.instanceMatrix.needsUpdate = true;
    meshGreen.instanceMatrix.needsUpdate = true;
    meshRed.instanceMatrix.needsUpdate = true;

    // 3. ç…§ç‰‡ä½ç½®æ›´æ–°
    if (STATE.mode !== 'ZOOM') { // ZOOMæ¨¡å¼ç”±GSAPæ§åˆ¶
        STATE.photos.forEach(photo => {
            let targetPos, targetRot;
            if (STATE.mode === 'TREE') {
                targetPos = photo.userData.treePos;
                targetRot = photo.userData.treeRot; // Euler
            } else {
                targetPos = photo.userData.scatterPos;
                targetRot = photo.userData.scatterRot;
            }

            photo.position.lerp(targetPos, lerpFactor);
            // æ—‹è½¬æ’å€¼æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€å•å¤„ç†
            if(STATE.mode === 'TREE') {
                // å›åˆ°æ ‘çš„è§’åº¦
                photo.rotation.x += (targetRot.x - photo.rotation.x) * 0.05;
                photo.rotation.y += (targetRot.y - photo.rotation.y) * 0.05;
                photo.rotation.z += (targetRot.z - photo.rotation.z) * 0.05;
            } else {
                photo.rotation.x += 0.005;
                photo.rotation.y += 0.005;
            }
        });
    }

    // æ¸²æŸ“
    composer.render();
}

animate();

// çª—å£å¤§å°è°ƒæ•´
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
